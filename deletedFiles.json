[
  {
    "source": "server/domain/model/taskModel.ts",
    "content": "import type { User } from '$/api/@types';\nimport type { TaskModel } from '$/api/@types/models';\nimport { S3_PREFIX } from '$/domain/repository/s3Repo';\nimport type { MultipartFile } from '@fastify/multipart';\nimport { randomUUID } from 'crypto';\n\nconst dataToUrl = (data: MultipartFile) => {\n  const s3Key = `tasks/images/${randomUUID()}.${data.filename.split('.').at(-1)}`;\n\n  return { url: `${S3_PREFIX}${s3Key}`, s3Key };\n};\n\nexport type DeletableTaskId = { type: 'DeletableTask'; val: string };\n\nexport const taskModel = {\n  create: (user: User, label: string, data: MultipartFile | undefined): TaskModel => ({\n    id: randomUUID(),\n    done: false,\n    label,\n    image: data === undefined ? undefined : dataToUrl(data),\n    createdTime: Date.now(),\n    author: { userId: user.id, name: user.name },\n  }),\n  deleteOrThrow: (user: User, task: TaskModel): DeletableTaskId => {\n    if (user.id !== task.author.userId) throw new Error('cannot delete');\n\n    return { type: 'DeletableTask', val: task.id };\n  },\n  updateOrThrow: (\n    user: User,\n    task: TaskModel,\n    updateData: { done: boolean; label: string }\n  ): TaskModel => {\n    if (user.id !== task.author.userId) throw new Error('cannot update task');\n\n    return { ...task, ...updateData };\n  },\n};\n"
  },
  {
    "source": "server/domain/repository/taskRepo.ts",
    "content": "import type { TaskModel } from '$/api/@types/models';\nimport type { DeletableTaskId } from '$/domain/model/taskModel';\nimport type { Prisma, Task, User } from '@prisma/client';\nimport { S3_PREFIX } from './s3Repo';\n\nconst toModel = (task: Task & { User: User }): TaskModel => ({\n  id: task.id,\n  label: task.label,\n  done: task.done,\n  createdTime: task.createdAt.getTime(),\n  image:\n    task.imageKey === null\n      ? undefined\n      : { url: `${S3_PREFIX}${task.imageKey}`, s3Key: task.imageKey },\n  author: { userId: task.userId, name: task.User.name },\n});\n\nexport const taskRepo = {\n  save: async (tx: Prisma.TransactionClient, task: TaskModel) => {\n    await tx.task.upsert({\n      where: { id: task.id },\n      update: { done: task.done, label: task.label, imageKey: task.image?.s3Key },\n      create: {\n        id: task.id,\n        userId: task.author.userId,\n        done: task.done,\n        label: task.label,\n        imageKey: task.image?.s3Key,\n        createdAt: new Date(task.createdTime),\n      },\n    });\n  },\n  delete: async (tx: Prisma.TransactionClient, deletableTaskId: DeletableTaskId) => {\n    await tx.task.delete({ where: { id: deletableTaskId.val } });\n  },\n  findAll: (tx: Prisma.TransactionClient, limit?: number): Promise<TaskModel[]> =>\n    tx.task\n      .findMany({ take: limit, include: { User: true }, orderBy: { createdAt: 'desc' } })\n      .then((tasks) => tasks.map(toModel)),\n  findByIdOrThrow: (tx: Prisma.TransactionClient, taskId: string): Promise<TaskModel> =>\n    tx.task.findUniqueOrThrow({ where: { id: taskId }, include: { User: true } }).then(toModel),\n};\n"
  }
]